#include <DAQCap.h>

#include <pcap.h>

#include <vector>
#include <stdexcept>
#include <cstring>
#include <string>

// TODO: Consider this library:
//       https://github.com/seladb/PcapPlusPlus

// TODO: We can control instantiation of the session handler while allowing
//       reinstantiation once it's been destroyed by storing a static bool
//       that tells us if it's currently instantiated.

// TODO: Prevent multiple instantiation?

// TODO: Try to get rid of throws

using namespace DAQCap;

unsigned int DATA_START = 14;

void listen(
	u_char *useless, 
	const struct pcap_pkthdr *pkthdr, 
	const u_char *packet_data
);

struct Packet {
    
    Packet(const struct pcap_pkthdr *header, const u_char *data);
    ~Packet();

    const struct pcap_pkthdr *header = nullptr;
    const u_char *data = nullptr;

};

// Global packet buffer we can use to get data out of the listen() function
std::vector<Packet> g_packetBuffer;

Packet::Packet(const struct pcap_pkthdr *header, const u_char *data)
    : header(header), data(data) {

}

Packet::~Packet() {

    if(header) delete header;
    header = nullptr;

    if(data) delete data;
    data = nullptr;

}

SessionHandler::SessionHandler(const Device &device, size_t wordSize) : lastPacket(-1) {

	char errorBuffer[PCAP_ERRBUF_SIZE];

    // Arguments: device name, snap length, promiscuous mode, to_ms, error_buffer
	handler = pcap_open_live(device.name.data(), 65536, 1, 10000, errorBuffer);
	if(!handler) {

		handler = nullptr;

		throw std::runtime_error(
			std::string("Could not open device ") 
                + device.name + " : " + errorBuffer
		);

	}

	// Compile the filter
	struct bpf_program fcode;
	bpf_u_int32 netmask = 0xffffff;
	char packetFilter[] = "ether src ff:ff:ff:c7:05:01";
	if(pcap_compile(handler, &fcode, packetFilter, 1, netmask) < 0) {

		pcap_freecode(&fcode);
		if(handler) pcap_close(handler);
		handler = nullptr;

		throw std::runtime_error(
			"Unable to compile the packet filter. Check the syntax!"
		);

	}

	if(pcap_setfilter(handler, &fcode) < 0) {

		pcap_freecode(&fcode);
		if(handler) pcap_close(handler);
		handler = nullptr;

		throw std::runtime_error(
			"Filter address error. Cannot apply filter!"
		);

	}

  	// pcap_freecode() is used to free up allocated memory pointed to by a
    // bpf_program struct generated by pcap_compile(3PCAP) when that BPF
    // program is no longer needed, for example after it has been made the
    // filter program for a pcap structure by a call to
    // pcap_setfilter(3PCAP).
	pcap_freecode(&fcode);

}

SessionHandler::~SessionHandler() {

	if(handler) pcap_close(handler);
	handler = nullptr;

}

void SessionHandler::interrupt() {

    if(handler) pcap_breakloop(handler);

}

DataBlob SessionHandler::fetchPackets(bool checkPackets) {

    DataBlob blob;

    // TODO: The point of the next block is to make pcap_dispatch timeout after
    //       a while. I'd prefer not to have to do this. We could timeout by,
    //       for example, creating a thread that calls interrupt() after some
    //       amount of time unless told otherwise.
    ///////////////////////////////////////////////////////////////////////////

    /*
	// Get a file descriptor for the packet capture device
	int fd = pcap_fileno(handler); 

	// File descriptor sets for "select" function (it's a bit array)
	fd_set rfds;

	FD_ZERO(&rfds); // re-clears (empty) file descriptor set
	FD_SET(fd, &rfds); // rebuild file descriptor set

	struct timeval tv;
	tv.tv_sec  = 10000;
	tv.tv_usec = 0    ;

    // TODO: Can we do this a better way? Maybe use <thread>?
    //       This makes interrupting the handler not work too.
    //select(): blocks the calling process until there is activity on file 
    //          descriptor set or until the timeout period has expired
	int selectSuccess = select(fd + 1, &rfds, NULL, NULL, &tv);
    
    if(-1 == selectSuccess) {

        blob.statusMessage = "Select failed";

        return blob;

	} 
    
    if(!selectSuccess) {

        blob.statusMessage = "Select timeout on fd: ";
        blob.statusMessage += fd;
        blob.statusMessage += " Return code: ";
        blob.statusMessage += selectSuccess;

        return blob;

	}
    */

    ///////////////////////////////////////////////////////////////////////////

    // TODO: Do we really want to count idle words in the total number of 
    //       packets?

    g_packetBuffer.clear();
    int ret = pcap_dispatch(
        handler, 
        -1, 
        listen,
        NULL
    );

    if(ret == -1) { // An error occurred

        // TODO: Error handling

        return blob;

    } else if(ret == -2) { // Packet fetching was interrupted

        // TODO: Error handling

        return blob;

    } else {

        blob.bufferedPackets = ret;

    }

    ///////////////////////////////////////////////////////////////////////////

    // TODO: Consider extracting out the validation code

    std::vector<unsigned char> idleWord(wordSize, 0xFF);

    for(const Packet &packet : g_packetBuffer) {

        int length = packet.header->len - 18; // bytes (preload = 14, postload = 4)

        ///////////////////////////////////////////////////////////////////////

        int packetNum = (int)(*(packet.data + length + 18 - 2) * 256);
        packetNum += (int)(*(packet.data + length + 18 - 1));

        if(checkPackets) {

            if(lastPacket != -1) {

                if(packetNum != (lastPacket + 1) % 65536) {

                    int missingPackets 
                        = (packetNum - (lastPacket + 1)) % 65536;

                    blob.errorMessages.push_back(
                        std::to_string(missingPackets) 
                            + " packets lost! Packet = "
                            + std::to_string(packetNum) 
                            + ", Last = " 
                            + std::to_string(lastPacket)
                    );

                    blob.lostPackets += missingPackets;

                }

            }

        }

        lastPacket = packetNum;

        ///////////////////////////////////////////////////////////////////////

        for(
            int iter = DATA_START; 
            iter < packet.header->len; 
            iter += wordSize
        ) {

            // TODO: Check that I have this condition the right way around
            if(
                std::memcmp(
                    packet.data + iter, idleWord.data(), wordSize
                ) != 0
            ) {

                blob.data.insert(
                    blob.data.end(), 
                    packet.data + iter, 
                    packet.data + iter + wordSize
                );

            }

        }

        ///////////////////////////////////////////////////////////////////////

    }

    return blob;

}

void listen(
	u_char *useless, 
	const struct pcap_pkthdr *pkthdr, 
	const u_char *packet_data
) {

    delete useless;
    useless = nullptr;

    g_packetBuffer.push_back(Packet(pkthdr, packet_data));

}

std::vector<Device> DAQCap::getDevices() {

    // TODO: Weed out inactive devices?

    pcap_if_t* deviceHandle = nullptr;
    char errorBuffer[PCAP_ERRBUF_SIZE];

    if(pcap_findalldevs(&deviceHandle, errorBuffer) == -1) {

        if(deviceHandle) pcap_freealldevs(deviceHandle);
        deviceHandle = nullptr;

        throw std::runtime_error(
            std::string("Error in pcap_findalldevs: ") + errorBuffer
        );

    }

    if(deviceHandle == nullptr) {

        throw std::runtime_error(
            "No network devices found. Check your permissions."
        );

    }

    std::vector<Device> devices;

    for(pcap_if_t* d = deviceHandle; d != nullptr; d = d->next) {

        Device device;
        device.name = d->name? d->name : "(Unknown Device)";
        device.description = d->description? d->description : "(No description available)";

        devices.push_back(device);

    }

    pcap_freealldevs(deviceHandle);
    deviceHandle = nullptr;

    return devices;

}