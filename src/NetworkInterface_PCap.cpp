#include "NetworkInterface.h"

#include <stdexcept>

#include <pcap.h>

using namespace DAQCap;

// Global packet buffer we can use to get data out of the listen() function.
// It's reallllllly nontrivial to get pcap_dispatch() to read data into a
// class member, so we have to use this global buffer instead. This is why
// two threads can't fetch packets from two different devices at the same time.
// Note that even without this, two threads would not be able to fetch packets
// from the same device at the same time.
std::vector<Packet> g_packetBuffer;

// Stores the packet data in g_packetBuffer. This function is passed as a 
// callback into pcap_dispatch() during packet fetching.
void listen_callback(
	u_char *useless, 
	const struct pcap_pkthdr *header, 
	const u_char *packet_data
);

class Listener::Listener_impl {

public:

    Listener_impl(const std::string &deviceName);
    ~Listener_impl();

    Listener_impl(const Listener_impl &other)            = delete;
    Listener_impl &operator=(const Listener_impl &other) = delete;

    void interrupt();
    std::vector<Packet> listen(int packetsToRead);

private:

    pcap_t *handler = nullptr;

};

Listener::Listener_impl::Listener_impl(const std::string &deviceName) {

	char errorBuffer[PCAP_ERRBUF_SIZE];

    // Arguments: device name, snap length, promiscuous mode, to_ms, error_buffer
	handler = pcap_open_live(deviceName.data(), 65536, 1, 10000, errorBuffer);
	if(!handler) {

		handler = nullptr;

		throw std::runtime_error(
			std::string("Could not open device ") 
                + deviceName + " : " + errorBuffer
		);

	}

	// Compile the filter
	struct bpf_program fcode;
	bpf_u_int32 netmask = 0xffffff;
	char packetFilter[] = "ether src ff:ff:ff:c7:05:01";
	if(pcap_compile(handler, &fcode, packetFilter, 1, netmask) < 0) {

		pcap_freecode(&fcode);
		if(handler) pcap_close(handler);
		handler = nullptr;

		throw std::runtime_error(
			"Unable to compile the packet filter. Check the syntax!"
		);

	}

	if(pcap_setfilter(handler, &fcode) < 0) {

		pcap_freecode(&fcode);
		if(handler) pcap_close(handler);
		handler = nullptr;

		throw std::runtime_error(
			"Filter address error. Cannot apply filter!"
		);

	}

  	// pcap_freecode() is used to free up allocated memory pointed to by a
    // bpf_program struct generated by pcap_compile(3PCAP) when that BPF
    // program is no longer needed, for example after it has been made the
    // filter program for a pcap structure by a call to
    // pcap_setfilter(3PCAP).
	pcap_freecode(&fcode);

}

Listener::Listener_impl::~Listener_impl() {

	if(handler) pcap_close(handler);
	handler = nullptr;

}

void Listener::Listener_impl::interrupt() {

    if(handler) pcap_breakloop(handler);

}

std::vector<Packet> Listener::Listener_impl::listen(int packetsToRead) {

    g_packetBuffer.clear();
    int ret = pcap_dispatch(
        handler, 
        packetsToRead, 
        listen_callback,
        NULL
    );

    if(ret == -1) { // An error occurred

        std::string errorMessage(pcap_geterr(handler));

        // TODO: Error handling

    } else if(ret == -2) { // Packet fetching was interrupted

        // TODO: Error handling

    } 
    
    return g_packetBuffer;

}

std::vector<Device> DAQCap::getDevices() {

    // TODO: Weed out inactive devices?

    pcap_if_t* deviceHandle = nullptr;
    char errorBuffer[PCAP_ERRBUF_SIZE];

    if(pcap_findalldevs(&deviceHandle, errorBuffer) == -1) {

        if(deviceHandle) pcap_freealldevs(deviceHandle);
        deviceHandle = nullptr;

        throw std::runtime_error(
            std::string("Error in pcap_findalldevs: ") + errorBuffer
        );

    }

    if(deviceHandle == nullptr) {

        throw std::runtime_error(
            "No network devices found. Check your permissions."
        );

    }

    std::vector<Device> devices;

    for(pcap_if_t* d = deviceHandle; d != nullptr; d = d->next) {

        Device device;

        device.name = d->name? 
            d->name : "(Unknown Device)";

        device.description = d->description? 
            d->description : "(No description available)";

        devices.push_back(device);

    }

    pcap_freealldevs(deviceHandle);
    deviceHandle = nullptr;

    return devices;

}

void listen_callback(
	u_char *useless, 
	const struct pcap_pkthdr *header, 
	const u_char *packet_data
) {

    g_packetBuffer.push_back({ packet_data, header->len });

    delete[] useless;
    useless = nullptr;

    delete header;
    header = nullptr;

    delete[] packet_data;
    packet_data = nullptr;

}

Listener::Listener(const std::string &deviceName) 
    : impl(new Listener_impl(deviceName)) {}

Listener::~Listener() {
    
    if(impl) delete impl;
    impl = nullptr;

}

void Listener::interrupt() { 

    impl->interrupt(); 

}

std::vector<Packet> Listener::listen(int packetsToRead) { 

    return impl->listen(packetsToRead); 

}